<PUBLIC:COMPONENT lightWeight="true">
<PUBLIC:ATTACH EVENT="oncontentready" ONEVENT="o.init()" />
<PUBLIC:ATTACH EVENT="ondocumentready" ONEVENT="o.init()" />
<PUBLIC:ATTACH EVENT="onpropertychange" ONEVENT="o.handlePropertychange()" />
<PUBLIC:ATTACH EVENT="ondetach" ONEVENT="o.restore()" />
<PUBLIC:ATTACH EVENT="onresize" FOR="window" ONEVENT="o.handleResize()" />
<script type="text/javascript">

var o; // and so it is

(function( element, spacerPath ) {

var rsrc = /url\(["']?(.*?)["']?\)/,
	positions = {
		top: 0,
		left: 0,
		bottom: 1,
		right: 1,
		center: .5
	},
	doc = element.document,
	spacer = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",
	noop = function() {},
	resizeInterval = 100,
	resizeId;

// don't allow anything until init() is called
o = {
	init: init,
	handlePropertychange: noop,
	restore: noop,
	handleResize: noop
};

if ( element.readyState == "complete" ) {
	init();
}

// remove the background-image and emulate it with a wrapped <img/>
function init() {
	var wrapper = doc.createElement( "div" ),
		img = doc.createElement( "img" ),
		wrapperStyle = wrapper.style,
		imgStyle = img.style,
		elementStyle = element.style,
		elementCurrentStyle = element.currentStyle;

	wrapperStyle.position = "absolute";
	wrapperStyle.zIndex = -1;
	wrapperStyle.top = 0;
	wrapperStyle.right = 0;
	wrapperStyle.left = 0;
	wrapperStyle.bottom = 0;
	wrapperStyle.overflow = "hidden";
	wrapperStyle.visibility = "inherit";

	img.alt = "";
	imgStyle.position = "absolute";
	imgStyle.width = imgStyle.height = "auto";
	imgStyle.visibility = "inherit";

	wrapper.appendChild( img );

	element.insertBefore( wrapper, element.firstChild );

	// save useful data for quick access
	element.bgsExpando = {
		wrapper: wrapper,
		img: img,
		style: {
			backgroundImage: elementStyle.backgroundImage,
			position: elementStyle.position,
			zIndex: elementStyle.zIndex
		}
	};

	// This is the part where we mess with the existing DOM
	// to make sure that the background image is correctly zIndexed
	if ( elementCurrentStyle.zIndex == "auto" ) {
		elementStyle.zIndex = 0;
	}
	if ( elementCurrentStyle.position == "static" ) {
		elementStyle.position = "relative";
	}

	// allow init() to be called only once
	o.init = noop;

	// check if browser supports our data uri spacer gif
	getImageDimensions( spacer, function( width, height ) {
		if ( width != 1 || height != 1 ) {
			spacer = spacerPath;
		}

		o = {
			init: noop,
			handlePropertychange: handlePropertychange,
			restore: restore,
			handleResize: handleResize
		};

		handlePropertychange();
	} );
}

// this prevents handling propertychange events caused by this script
function suspendPropertychange( callback ) {
	var fn = o.handlePropertychange;
	o.handlePropertychange = noop;
	callback();
	o.handlePropertychange = fn;
}

function refreshDisplay( element, expando ) {
	var display = element.currentStyle.display;

	if ( display != expando.display ) {
		expando.display = display;
		expando.changed = true;
	}

	return display != "none";
}

function refreshDimensions( element, expando ) {
	var elementCurrentStyle = element.currentStyle,
		innerWidth = element.offsetWidth
			- ( parseFloat( elementCurrentStyle.borderLeftWidth ) || 0 )
			- ( parseFloat( elementCurrentStyle.borderRightWidth ) || 0 ),
		innerHeight = element.offsetHeight
			- ( parseFloat( elementCurrentStyle.borderTopWidth ) || 0 )
			- ( parseFloat( elementCurrentStyle.borderBottomWidth ) || 0 );

	if ( innerWidth != expando.innerWidth || innerHeight != expando.innerHeight ) {
		expando.innerWidth = innerWidth;
		expando.innerHeight = innerHeight;
		expando.changed = true;
	}
}

function refreshBackgroundProperties( element, expando ) {
	var elementCurrentStyle = element.currentStyle,
		pos = [
			elementCurrentStyle.backgroundPositionX,
			elementCurrentStyle.backgroundPositionY
		],
		size = elementCurrentStyle["background-size"],
		// Only keywords or percentage values are supported
		posX = positions[ pos[0] ] || parseFloat( pos[0] ) / 100 || 0,
		posY = positions[ pos[1] ] || parseFloat( pos[1] ) / 100 || 0;

	if ( size != expando.size || posX != expando.posX || posY != expando.posY ) {
		expando.size = size;
		expando.posX = posX;
		expando.posY = posY;
		expando.changed = true;
	}
}

function refreshBackgroundImage( element, expando, callback ) {
	var elementStyle = element.style,
		expandoStyle = expando.style,
		img = expando.img,
		imgStyle = img.style,
		src;

	if ( ( rsrc.exec( elementStyle.backgroundImage ) || [] )[1] == spacer ) {
		suspendPropertychange( function() {
			elementStyle.backgroundImage = expandoStyle.backgroundImage;
		} );
	} else {
		expandoStyle.backgroundImage = elementStyle.backgroundImage;
	}

	src = ( rsrc.exec( element.currentStyle.backgroundImage ) || [] )[1];

	suspendPropertychange( function() {
		elementStyle.backgroundImage = "url('" + spacer + "')";
	} );

	if ( src != expando.src ) {
		expando.src = src;
		expando.changed = true;

		if ( src ) {
			getImageDimensions( src, function( width, height ) {
				expando.imgWidth = width;
				expando.imgHeight = height;
				expando.constrain = false;

				callback();
			} );

			img.src = src;

		} else {
			expando.imgWidth = 0;
			expando.imgHeight = 0;
			expando.constrain = false;

			callback();
		}

	} else {
		// the callback should be executed in all cases
		callback();
	}
}

function updateBackground( element, expando ) {
	var img = expando.img,
		imgStyle = img.style,
		innerWidth = expando.innerWidth,
		innerHeight = expando.innerHeight,
		imgWidth = expando.imgWidth,
		imgHeight = expando.imgHeight,
		prevConstrain = expando.constrain,
		curConstrain,
		elemRatio,
		imgRatio,
		delta,
		display;

	if ( expando.changed ) {
		if ( innerWidth && innerHeight && imgWidth && imgHeight ) {
			elemRatio = innerWidth / innerHeight;
			imgRatio = imgWidth / imgHeight;

			if ( expando.size == "contain" ) {
				if ( imgRatio > elemRatio ) {
					expando.constrain = curConstrain = "width";

					delta = Math.floor(
						( innerHeight - innerWidth / imgRatio )
						* expando.posY
					);

					imgStyle.top = delta + "px";

					// when switching from height to width constraint,
					// make sure to release constraint on height and reset left
					if ( curConstrain != prevConstrain ) {
						imgStyle.width = "100%";
						imgStyle.height = "auto";
						imgStyle.left = 0;
					}
		
				// elemRatio > imgRatio
				} else {
					expando.constrain = curConstrain = "height";

					delta = Math.floor(
						( innerWidth - innerHeight * imgRatio )
						* expando.posX
					);

					imgStyle.left = delta + "px";

					if ( curConstrain != prevConstrain ) {
						imgStyle.width = "auto";
						imgStyle.height = "100%";
						imgStyle.top = 0;
					}
				}

			} else if ( expando.size == "cover" ) {
				if ( imgRatio > elemRatio ) {
					expando.constrain = curConstrain = "height";

					delta = Math.floor(
						( innerHeight * imgRatio - innerWidth )
						* expando.posX
					);

					imgStyle.left = -delta + "px";

					// when switching from height to width constraint,
					// make sure to release constraint on height and reset left
					if ( curConstrain != prevConstrain ) {
						imgStyle.width = "auto";
						imgStyle.height = "100%";
						imgStyle.top = 0;
					}
		
				// elemRatio > imgRatio
				} else {
					expando.constrain = curConstrain = "width";

					delta = Math.floor(
						( innerWidth / imgRatio - innerHeight )
						* expando.posY
					);

					imgStyle.top = -delta + "px";

					if ( curConstrain != prevConstrain ) {
						imgStyle.width = "100%";
						imgStyle.height = "auto";
						imgStyle.left = 0;
					}
				}
			}

			display = "block";

		} else {
			display = "none";
		}

		imgStyle.display = display;
	}

	expando.changed = false;
}

// handle different style changes
function handlePropertychange() {
	var expando = element.bgsExpando;

	if ( refreshDisplay( element, expando ) ) {
		refreshDimensions( element, expando );
		refreshBackgroundProperties( element, expando );
		refreshBackgroundImage( element, expando, function() {
			updateBackground( element, expando );
		});
	}
}

function handleResize() {
	clearTimeout( resizeId );
	resizeId = setTimeout( updateAfterResize, resizeInterval );
}

function updateAfterResize() {
	var expando = element.bgsExpando;

	if ( expando.display != "none" ) {
		refreshDimensions( element, expando );
		updateBackground( element, expando );
	}
}

function restore() {
	var expando = element.bgsExpando,
		elementStyle = element.style,
		expandoStyle;

	clearTimeout( resizeId );

	o = {
		init: noop,
		handlePropertychange: noop,
		restore: noop,
		handleResize: noop
	};

	try {
		expandoStyle = expando.style;
		elementStyle.backgroundImage = expandoStyle.backgroundImage;
		elementStyle.position = expandoStyle.position;
		elementStyle.zIndex = expandoStyle.zIndex;

		element.removeChild( expando.wrapper );

		element.bgsExpando = null;
	} catch ( e ) {}
}

function getImageDimensions( src, callback ) {
	var img = doc.createElement( "img" );

	img.onload = img.onerror = function() {
		callback( img.width, img.height );
		img = img.onload = img.onerror = null;
	};

	img.src = src;
}

})( element, window.bgsSpacerGif );

</script>

<!--
Work around IE sillyness, see:
http://www.pcreview.co.uk/forums/htc-components-512-bytes-javascript-slow-unload-t727396.html
https://github.com/lojjic/PIE/blob/master/sources/htc_markup.htc
https://code.google.com/p/svgweb/source/browse/trunk/src/svg.htc
-->
<script type="text/vbscript"></script>
</PUBLIC:COMPONENT>
